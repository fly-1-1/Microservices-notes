# 1 简介

​	protobuf是google旗下的一款平台无关，语言无关，可扩展的序列化结构数据格式。所以很适合用做数据存储和作 为不同应用，不同语言之间相互通信的数据交换格式，只要实现相同的协议格式即同一 proto文件被编译成不同的 语言版本，加入到各自的工程中去。这样不同语言就可以解析其他语言通过 protobuf序列化的数据。目前官网提 供了 C++,Python,JAVA,GO等语言的支持。google在2008年7月7号将其作为开源项目对外公布。 

​	Google Protocol Buffer(简称 Protobuf)是一种轻便高效的结构化数据存储格式，平台无关、语言无关、可扩展， 可用于通讯协议和数据存储等领域。 

## 优势

1：序列化后体积相比Json和XML很小，适合网络传输 

2：支持跨平台多语言 

3：消息格式升级和兼容性还不错 

4：序列化反序列化速度很快，快于Json的处理速速

​	Protobuf 有如 XML，不过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代 码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构 进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。 它有一个非常棒的特 性，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。 Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以 对 Protobuf 数据进行序列化、反序列化操作）。使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程 模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技 术更加有吸引力
​	想象一下你正在建造一座信息传递的大桥，这个桥横跨在两个岸之间，负责传递各种信息。现在，你需要选择一种方式来确保这座桥既能高效运输信息，又能节省资源。这时，Protocol Buffers（protobuf）就像是一种先进的桥梁建造技术，带来了许多优点：

1. **紧凑性：** protobuf 使用二进制编码，相较于文本格式（如 XML 和 JSON），它的编码更为紧凑。这就好比说，protobuf 把信息像精巧的拼图一样紧密打包，减少了桥上需要携带的石块数量。

2. **效率：** 由于紧凑的编码方式，protobuf 传输的数据量更小，传输速度更快。这就好比说，桥上的车辆可以更迅速地通过，不会发生拥堵。

3. **性能：** 由于数据紧凑，protobuf 的解析速度更快，占用更少的内存。这就好比说，桥的结构设计更为科学，能够支撑更多的车辆而不影响通行速度。

4. **语言无关性：** protobuf 支持多种编程语言，就像一座可以用多种材料搭建的桥，不受材料种类的限制。这使得不同的系统和服务可以无缝地交流信息。

5. **演进性：** protobuf 具有良好的版本控制和向前兼容性，就好比说，你可以在桥上新增一些通道或者调整桥的结构，而不会影响到现有的通行。

6. **代码生成：** protobuf 提供了自动生成代码的工具，这就好比是一座桥梁建造机器，能够根据桥的设计图纸自动构建出桥的各个部分。

   综合来看，protobuf 就像是一座高效、紧凑、灵活且先进的大桥，为信息传递提供了一种优秀的技术方案。通过选择 protobuf，你就能够在两岸之间搭建一座高速畅通、资源利用率高的信息传递之桥。

## 不足

​	Protobuf 与 XML 相比也有不足之处。它功能简单，无法用来表示复杂的概念。 XML 已经成为多种行业标准的编 写工具，Protobuf 只是 Google 公司内部使用的工具，在通用性上还差很多。 由于文本并不适合用来描述数据结 构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自 解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义， 否则你没法直接读出 Protobuf 的任何内容。 

1. **人可读性差：** protobuf 使用二进制编码，这使得数据在传输过程中难以直观地查看和理解。就像是桥上的灯光虽然美丽，但对于人们来说不容易辨认其中的图案。
2. **调试困难：** 由于数据以二进制形式存在，调试过程相对复杂。就像是城市桥梁出现问题时，维修人员需要先了解桥下的结构，再进行修复。
3. **人工可读格式差：** protobuf 的序列化数据不像 JSON 或 XML 那样容易被人类阅读，这增加了开发人员在处理数据时的难度。这就好比城市桥梁上的标识语言只有专业人士才能理解。
4. **不适合一些场景：** 在一些需要人工编辑或调试的场景中，protobuf 不如文本格式（比如 JSON）直观。这就好比在城市桥梁中进行特殊设计时，需要更多的手工操作。
5. **学习曲线：** 使用 protobuf 需要一些学习，因为需要理解其特殊的数据结构和使用方法。就像是城市桥梁的设计师需要掌握先进的桥梁建造技术。

##    .proto文件生成了什么

​	当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文 件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。 对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的 类。 对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的 模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。 对go来 说，编译器会为每个消息类型生成了一个.pd.go文件。 

# 2 使用

## 1 默认值

​	当一个消息被解析的时候，如果被编码的信息不包含一个特定的元素，被解析的对象锁对应的域被设置位一个默认 值，对于不同类型指定如下： 对于strings，默认是一个空string 对于bytes，默认是一个空的bytes 对于bools默认是false 对于数值类型，默认是0  

```
message PersonInfo {
repeated Person info = 1;
}
message Person {
string name = 1;
int32 shengao = 2;
repeated int32 tizhong = 3;
}
```

